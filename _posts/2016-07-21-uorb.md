---
layout: default
title: uORB学习
---
[TOC]
##通讯方式
The micro Object Request Broker (uORB) application is used to share data structures between threads and applications.
Communications between processes / applications (e.g. sending sensor values from the sensors app to the attitude filter app) is a key part of the PX4 software architecture. Processes (often called nodes in this context) exchange messages over *named buses*, called **topics**(topics也可以叫做bus). 
To make this efficient, there is always *onlyone message on the bus and no queue is kept*.(一个topic里面只包含一中信息，并且不设置排队机制)

uORB是Pixhawk系统等都要从芯片获中非常重要且关键的一个模块，它肩负了整个系统的数据传输任务，所有的传感器数据、GPS、PPM信号取后通过uORB进行传输到各个模块进行计算处理。uORB全称为micro object request broker (uORB),即 微对象请求代理器，实际上uORB是一套跨进程的IPC通讯模块。在Pixhawk中， 所有的功能被独立以进程模块为单位进行实现并工作。而进程间的数据交互就由为重要，必须要能够符合实时、有序的特点。

uORB实际上是多个进程打开同一个设备文件，进程间通过此文件节点进行数据交互和共享。uORB的实现位于固件源码的src/modules/uORB/uORB.cpp文件，它通过重载CDev基类来组织一个uORB的设备实例。并且完成Read/Write等功能的重载。uORB 的入口点是uorb_main函数，在这里它检查uORB的启动参数来完成对应的功能，uORB支持start/test/status这3条启动参数，在Pixhawk的rcS启动脚本中，使用start参数来进行初始化，其他2个参数分别用来进行uORB功能的自检和列出uORB的当前状态。

在rcS中使用start参数启动uORB后，uORB会创建并初始化它的设备实例， 其中的实现大部分都在CDev基类完成。这个过程类似于Linux设备驱动中的Probe函数，或者Windows 内核的DriverEntry，通过init调用完成设备的创建，节点注册以及派遣例程的设置等。
##代码解析
###uORB定义
目前uORB命名空间中只有一个类型，继承自其他类  *uORBManager.hpp: 50-60*
```
namespace uORB
{
    class Manager;
}

class uORB::Manager  : public uORBCommunicator::IChannelRxHandler
```

###程序解析
####ORB_DECLARE(topicName)
宏函数    *uORB.h: 94-100*    只对topicName进行定义，相当于定义了一个全局的orb_metadata __orb_topicName
```
# define ORB_DECLARE(_name)	 extern "C" const struct orb_metadata __orb_##_name __EXPORT
```
**orb_metadata**    topic 目标元数据（用来描述数据的数据，包含两个信息：数据名称和数据长度）确保数据在更新和拷贝时候的正确性，包含了目标名称和长度两个信息  *uORB.h: 52-55*
```
struct orb_metadata {
    const char *o_name;	 /**< unique object name */
    const size_t o_size;	 /**< object size */
};
```

####ORB_DEFINE(topicName)
宏函数    *uORB.h:114-120*     对之前申明的__orb_topicName进行初始化
```
#define ORB_DEFINE(_name, _struct)	 \
const struct orb_metadata __orb_##_name = {	\
#_name,	 \     /*# 变量字符串化操作*/
sizeof(_struct)	 \
}; struct hack

__BEGIN_DECLS
```
####ORB_ID(topicName)
宏函数  *uorb.h: 87*    用于得到该topic元数据meta的地址
```
#define ORB_ID(_name)	 &__orb_##_name 
```


####<span id = "ioctl">int uORB::DeviceNode::ioctl(...)和uorb_...各个函数的关系及实现</span>
位置*uORBDevices_nuttx.cpp: 263-292*
```
int uORB::DeviceNode::ioctl(struct file *filp, int cmd, unsigned long arg)
{
    SubscriberData *sd = filp_to_sd(filp);
    switch (cmd) {
        case ORBIOCLASTUPDATE:/*被orb_stat调用 -bdai<2016-04-23>*/
        *(hrt_abstime *)arg = _last_update;/*将目标上次的时间返回给arg指向的变量 -bdai<2016-04-23>*/
        return OK;

        case ORBIOCUPDATED:/*被orb_check调用, -bdai<2016-04-23>*/
        *(bool *)arg = appears_updated(sd);/*用于判断当前线程(subscribe调用的位置)中的数据是否更新，通过对比当前的sd中的generation和publish的topic的generation的值-bdai<2016-04-23>*/
        return OK;
       
        case ORBIOCSETINTERVAL:/*被orb_set_interval调用 -bdai<2016-04-23>*/
        sd->update_interval = arg;/*将update_interval赋值为arg(微秒级别) -bdai<2016-04-23>*/
        return OK;

        case ORBIOCGADVERTISER:/*被orb_advertise[_multi]调用 -bdai<2016-04-23>*/
        *(uintptr_t *)arg = (uintptr_t)this;/*将当前创建的DeviceNode地址返回给arg参数 -bdai<2016-04-23>*/
        return OK;

        case ORBIOCGPRIORITY:/*被orb_prriority调用 -bdai<2016-04-23>*/
        *(int *)arg = sd->priority;/*用于获得当前subcriberdata的priority属性 -bdai<2016-04-23>*/
        return OK;

        default:
        /* give it to the superclass */
        return CDev::ioctl(filp, cmd, arg);
    }
}
```

#### orb_advert_t orb_advertise(const struct orb_metadata \*meta, const void \*data)
位置：*uORB.cpp: 65*
功能：在*/obj*中创建一个*topic*的节点，主要就是告诉大家此处为publisher，并且调用了orb_publish(...)进行第一次的publish，返回值是一个指向该*topic*的handle。任何advertiser都可以对一个topic进行publish，也就是说对于同一个topic可以在不同处对其进行pulish。
**分析：**
**1. **首先通过`uORB::Manager::get_instance()->...`获得一个instance，所有线程只有一个instance，在第一次调用的时候创建，相当于是一个方法的集合，而instance是一个入口。位置：*uORBManager_nuttx.cpp: 49-56*
```
uORB::Manager *uORB::Manager::get_instance()
{
    if (_Instance == nullptr) {
        _Instance = new uORB::Manager();/*所有程序中应该只有一个_Instance，相当于包含了很多方法的一个入口 -bdai<2016-04-23>*/
        }

return _Instance;
}
```

**2.**调用 `uORB::Manager::get_instance()->orb_advertise_multi(meta, data, nullptr, ORB_PRIO_DEFAULT)`，返回一个指向meta所描述的topic的句柄
位置*uORBManager_nuttx.cpp: 89-123*
```
/**fun: 返回一个指向meta所描述的topic的句柄
 * parame: meta:用于描述topic的元数据， data：初始数据
 * return: advertiser:指向meta描述的topic的句柄
 * reader: daibo<bdai1412@gmail.com>  2016-04-23 22:13
 */
uORB::Manager::get_instance()->orb_advertise_multi(meta, data, nullptr, ORB_PRIO_DEFAULT)
{
    int result, fd; 
    orb_advert_t advertiser;

    /* open the node as an advertiser */
    fd = node_open(PUBSUB, meta, data, true, instance, priority);
    ...
    result = ioctl(fd, ORBIOCGADVERTISER, (unsigned long)&advertiser); /*通过不同的指令实现不同的函数*/
    ...
    result = orb_publish(meta, advertiser, data);
    ...
    return advertiser;
}
```
这一函数中又有两个函数用到，因此第二步可以分为两步：
**2.1**调用node_open(PUBSUB, meta, data, true, instance, priority)，返回该topic的新的node的fd
位置：uORBManaer_nuttx.cpp:222-303
过程：先获得该topic的路径*path*，再通过该路径得到该topic的`fd(file descriptor)`，通过该fd判断该topic的note是否存在，如果存并且此时是advertiser，则关闭该fd并创建新的Note指向该topic，最后返回新的fd。
<span id = "node_open"></span>
```
int uORB::Manager::node_open(Flavor f,const struct orb_metadata *meta,const void *data,bool advertiser,int *instance,int priority)
{
    ...

    ret = uORB::Utils::node_mkpath(path, f, meta, instance);/*将mate->o_name字符串赋给path指针 -bdai<2016-04-23>*/
    ...
    /* open the path as either the advertiser or the subscriber */
    fd = open(path, (advertiser) ? O_WRONLY : O_RDONLY);    
    
    /*如果note存在，并且此时需要advertise这个topic -bdai<2016-04-23>*/
    if ((fd >= 0) && (instance != nullptr) && (advertiser)) {
    	/* close the fd, we want a new one */
    	close(fd);
    	/* the node_advertise call will automatically go for the next free entry */
   	 fd = -1;
    	}
    /*创建新的DeviceNode -bdai<2016-04-23>*/
    if (fd < 0) {
    	/* try to create the node */
    ret = node_advertise(meta, instance, priority);
    if (ret == OK){
    ret = uORB::Utils::node_mkpath(path, f, meta, instance);/*获得meta的新的路径 -bdai<2016-04-23>*/
    ...
    }
    ...
    fd = open(path, (advertiser) ? O_WRONLY : O_RDONLY);
    }
...
}
```
**2.2**通过ioctl(fd, ORBIOCGADVERTISER, (unsigned long)&advertiser)获得fd所描述的topic的句柄，并将该句柄赋给advertiser。该过程又可以分为两步：
2.2.1首先进入int ioctl(int fd, int req, unsigned long arg)
位置：*fs_ioctl.c: 87-149*
过程：首先跳转到int ioctl(int fd, int req, unsigned long arg)函数，该函数一共有三个参数，分别是文件描述fd， ioctl指令，和cmd参数 arg。**在该函数中首先对fd进行了解析，得到fd所描述的文件，然后通过该文件的得到其node节点**，最后通过函数重载和一个选择列表实现不同的req对应的功能。
```
int ioctl(int fd, int req, unsigned long arg)
{
    ...
    this_file = &list->fl_files[fd];/*通过fd得到该文件 -bdai<2016-04-23>*/
    inode     = this_file->f_inode;/*得到该文件后，可以得到该文件的node节点 -bdai<2016-04-23>*/
    ...
    ret = (int)inode->u.i_ops->ioctl(this_file, req, arg);/*通过函数重载，对于不同的req具有不同的功能 -bdai<2016-04-23>*/    
    ...
```
2.2.2通过函数的重载得到在ioctl的具体实现：[int uORB::DeviceNode::ioctl(struct file *filp, int cmd, unsigned long arg)](#ioctl)
不同的cmd，对应于不同的指令，分别对应于orb_start, orb_check等。
位置：uORBDevices_nuttx.cpp: 262-292


####int  orb_publish(const struct orb_metadata \*meta, orb_advert_t handle, const void \*data)
位置：uORB.cpp: 155
功能：将新的数据publish到topic中，即将data的数据放到handle所指向的topic中，返回值为ERROR或者OK
**分析：**
第一个参数mete适用于来校对数据，防止出现错误。
```
位置：uORBDevices_nuttx.cpp: 294-337
uORB::DeviceNode::publish(...)
{
    ...
    uORB::DeviceNode *DeviceNode = (uORB::DeviceNode *)handle;/*获得topic的指针，此时DeviceNode包含了该信息 -bdai<2016-04-24>*/
    ...
    ret = DeviceNode->write(nullptr, (const char *)data, meta->o_size);/*更新topic的数据 -bdai<2016-04-24>*/
    ...
    send_message(meta->o_name, meta->o_size, (uint8_t *)data) != 0) /*if the write is successful, send the data over the Multi-ORB link*/
    ...

}
```
**分析DeviceNode->write函数**位置：uORBDevices_nuttx.cpp: 210-260
```
ssize_t uORB::DeviceNode::write(struct file *filp, const char *buffer, size_t buflen)
{
    ...
    memcpy(_data, buffer, _meta->o_size);/*将buffer的数据拷贝到DeviceNode节点的_data属性中 -bdai<2016-04-24>*/
    ...
    
    /* update the timestamp and generation count */
    _last_update = hrt_absolute_time();
    generation++;/*该属性用于和不同线程的subscribe中的sd(subscribedata)generaion进行对比，从而确定订阅了该topic的数据有没有更新，即orb_chech -bdai<2016-04-24>*/
    ...

}
```

####int  orb_subscribe(const struct orb_metadata \*meta)
位置：uORB.cpp: 186
功能：返回meta中包含的topic所在位置的handle
**分析：**
通过调用[node_open(PUBSUB, meta, nullptr, false)](#node_open)获得topic的文件描述fd，每个线程的调用subscribe一次生成该线程的fd，因此不同线程对于同一个topic的fd是不一样的，该fd包含了该线程对topic的操作，从而区分了不同线程对于同一个topic的操作。

####int orb_unsubscribe(int handle)
位置：uORB.cpp: 231
功能：关闭文件描述fd，即取消订阅

####int orb_check(int handle, bool \*updated)
位置：uORB.cpp: 275
功能：检查某个handle指向的topic自从上一次orb_copy之后是否更新。
分析：在uORBManager_nuttx.cpp文件中 int uORB::Manager::orb_check(int handle, bool \*updated)通过调用[ioctl(handle, ORBIOCUPDATED, (unsigned long)(uintptr_t)updated)](#ioctl)然后调用appears_updated(SubscriberData *sd)函数
位置：uORBDevices_nuttx.cpp: 368-444
```
bool uORB::DeviceNode::appears_updated(SubscriberData *sd)
{
    bool ret = false;/*默认为false没有更新数据可用 -bdai<2016-04-25>*/
    irqstate_t state = irqsave();/*Lock，应该是为了防止此处程程序被中断，感觉没啥用 -bdai<2016-04-25>*/
    if (_data == nullptr) {/*数据并没有被published，一次都没有 -bdai<2016-04-25>*/
    ret = false;
    goto out;
    }

    while (sd->generation != _generation) {/*对比sd中的generation和topic的generation，如果不一样，说明数据被publish了 -bdai<2016-04-25>*/
        if (sd->update_interval == 0) {/*是否设置更新间隔，如果没有，直接返回true -bdai<2016-04-25>*/
            ret = true;
            break;
        }

        if (sd->update_reported) {/*如果上一次检查过了并且有新的publish的数据，则此时不用再检查 -bdai<2016-04-25>*/
            ret = true;
            break;
        }

        if (!hrt_called(&sd->update_call)) {/*如果定时间隔还没有到，此时就不更新标志 -bdai<2016-04-25>*/
                break;
            }
    
            hrt_call_after(&sd->update_call,/*类似于给定时器初始化，重新计算时间间隔 -bdai<2016-04-25>*/
        	       sd->update_interval,
        	       &uORB::DeviceNode::update_deferred_trampoline,
        	       (void *)this);
    
            sd->update_reported = true;
            ret = true;
    	         break;
     }
    
out:
    irqrestore(state);/*unlock -bdai<2016-04-25>*/
    return ret;
}
```
#####uORB设备的“POLL”状态
该poll状态并不是系统的poll，而是通过函数来实现topic的定时获取
当用户没有指定数据读取的频率时，每次源的write都会向用户提供数据可读取的信息。是否唤醒除了检查generation的值以外，另外一个要求就是读取频率的限制，每个用户可以单独指定自己打算读更新的频率。uORB 根据用户指定的周期来设置hrt（实时定时器），每过一个时间间隔，hrt会被发生调用，通过hrt_called来检查这个调用。如果未发生，即便此时源的数据已经更新那么也不会返回POLLIN来唤醒用户去读。 简单来说，它通过控制POLLIN的周期来单方面控制用户的读取间隔。 

####int  orb_copy(const struct orb_metadata \*meta, int handle, void \*buffer)
位置：uORB.cpp: 252
形式：int  orb_copy(const struct orb_metadata *meta, int handle, void *buffer)
功能：从handle指向的topic中获得数据到buffer中，meta用于数据的检验，并且在orb_copy中，将sd存储的generation设置为topic中的generation，从而表明拷贝的数据是最新的数据。且该实现是通过调用uORB::DeviceNode::read(struct file *filp, char *buffer, size_t buflen)实现的。
位置：uORBDevices_nuttx.cpp: 168-207
分析：过程比较复杂，和publish比较类似，首先在uorb_copy调用文件系统fs_read.c中read(...)，read又调用file_read(...)，在file_read中对调用了note类中的read(也即是uORB::DeviceNode::read)。
```
ssize_t uORB::DeviceNode::read(struct file *filp, char *buffer, size_t buflen)
{
    ...
    sd->generation = _generation;/*将sd中的generation设置为最新值，从而表明数据已经更新 -bdai<2016-04-25>*/
    sd->priority = _priority;/*将获得的topic的数据的优先级也赋给sd，从而可以分别出不同的数据源 -bdai<2016-04-25>*/
    sd->update_reported = false;
    ...
```

####int  orb_stat(int handle, uint64_t *time)
位置：uORB.cpp: 288
分析：用于查询subscribe线程更新的topic的时用了[ioctl(handle, ORBIOCLASTUPDATE, (unsigned long)(uintptr_t)time)](#ioctl)函数

####int uORB::Manager::orb_priority(int handle, int32_t *priority)
位置：uORB.cpp: 332
分析：用于获得订阅的topic的优先级，调用了[return ioctl(handle, ORBIOCGPRIORITY, (unsigned long)(uintptr_t)priority)](#ioctl)函数

####orb_set_interval(int handle, unsigned interval)
位置：uORB.cpp: 355
分析：用于设置subcribe更新时间间隔，调用了[ioctl(handle, ORBIOCSETINTERVAL, interval * 1000)](#ioctl)函数

####int  orb_exists(const struct orb_metadata *meta, int instance)
位置：uORB.cpp: 300
分析：用于查询一个topic是否已经存在

####int  orb_group_count(const struct orb_metadata *meta)
位置：uORB.cpp: 309-318
分析：通过将instance从0开始遍历，调用orb_exists，从而获得当前的instance数量
```
int  orb_group_count(const struct orb_metadata *meta)
{
    unsigned instance = 0;
    while (uORB::Manager::get_instance()->orb_exists(meta, instance) == OK) {
        ++instance;
    };
    return instance;
}
```
###orb_advertise、orb_advertise_multi和orb_subscribe和orb_subscribe_multi分析
代码位置：uORBManager_nuttx.cpp
```
orb_advert_t uORB::Manager::orb_advertise(const struct orb_metadata *meta, const void *data)
{
    return orb_advertise_multi(meta, data, nullptr, ORB_PRIO_DEFAULT);
}

orb_advert_t uORB::Manager::orb_advertise_multi(const struct orb_metadata *meta, const void *data, int *instance,
int priority)
{
    ...
    fd = node_open(PUBSUB, meta, data, true, instance, priority);
    ...
}

int uORB::Manager::orb_subscribe(const struct orb_metadata *meta)
{
    return node_open(PUBSUB, meta, nullptr, false);
}

int uORB::Manager::orb_subscribe_multi(const struct orb_metadata *meta, unsigned instance)
{
    	int inst = instance;
    	return node_open(PUBSUB, meta, nullptr, false, &inst);
}
```
如下图所示：当调用advertise_multi时，可以对同一个topic创建不同的实例instance，也就是说，对于不同的模块，可以对同一个topic进行更新。线程在publish的时候传入instance的句柄handle，如此只会其handle所指向的instance进行更新。同样的对于subscribe_multi来说包含了instance参数，它只会订阅该instance所代表的topic。而advertise和subscribe只会创建和订阅默认的topic的instance，该instance只有一个，因此不同地方对同一个topic更新时，会覆盖掉之前publish的topic的值。



##快速开始
一般正常使用分为三部分，分别是：
+ 申明topic类型结构，ORB_DECLARE，这部分现在通过msg自动生成，在msg/文件中，以前是通过添加topicName.文件实现
+ publish该topic，这一过程分为三步：
    + 初始化meta文件ORB_DEFINE(topicName, topicName_s)，该部分绝大多数在uORB/objects_common.cpp中完成
    + 调用advertise向所有人广播，一般在需要发布该topic的线程中
    + 调用publish更新topic
+ subscribe该topic，这一过程分为三步
    + subscribe该topic，一般在需要改topic的线程中
    + check该topic有没有更新
    + copy该topic

###旧方法通过.h实现
topic.h
```
/* declare the topic */
 ORB_DECLARE(random_integer);/* define the data structure that will be published where subscribers can see it */
 struct random_integer_data {/*新版本叫struct randow_integer_s以s结尾*/
 int r; 
};
```
publisher.c
```

#include <topic.h>
 
/* create topic metadata */
ORB_DEFINE(random_integer); /*新版本有两个参数 ORB_DEFINE(random_integer, random_integer_s)*/
 
/* file handle that will be used for publishing */
static int topic_handle;
 
int init() {
/* generate the initial data for first publication */
struct random_integer_data rd = { .r = random(), };
 
/* advertise the topic and make the initial publication */
topic_handle = orb_advertise(ORB_ID(random_integer), &rd);
}

int update_topic() {
/* generate a new random number for publication */
struct random_integer_data rd = { .r = random(), };
/* publish the new data structure */
orb_publish(ORB_ID(random_integer), topic_handle, &rd);
}
```
subscriber.c
```

#include <topic.h>

 

/* file handle that will be used for subscribing */

static int topic_handle;

 

int

init()

{

    /* subscribe to the topic */

    topic_handle = orb_subscribe(ORB_ID(random_integer));

}

 

void

check_topic()

{

    bool updated;

    struct random_integer_data rd;

 

    /* check to see whether the topic has updated since the last time we read it */

    orb_check(topic_handle, &updated);

 

    if (updated) {

        /* make a local copy of the updated data structure */

        orb_copy(ORB_ID(random_integer), topic_handle, &rd);

        printf("Random integer is now %d\n", rd.r);

    }

```

###新方法通过.msg实现[https://pixhawk.org/dev/add_uorb_topic](https://pixhawk.org/dev/add_uorb_topic)

####Add a uORB topic

   + Add a new message definition file in the Firmware/msg folder with following contents

    ```

    uint64	timestamp          # Timestamp 
    uint64 time_start_usec     # starting time of the trajectory. 
    uint64 time_stop_usec      # stopping time of the trajectory. 
    float32[28] coefficients   # coefficients of the polynomial trajectory. 
    uint16 seq_id              # sequence id of the sent trajectory piece.    
    ```
   + Edit the Firmware/src/modules/uORB/objects_common.cpp and add the following
    ```
    #include "topics/ca_trajectory.h" 
    ORB_DEFINE(ca_trajectory, struct ca_traj_struct_s);
    ```
#### Add a uORB topic group 多个地方可以publish
Sometimes multiple instances of a device / driver are wanted, for example three accelerometers. However, all of them use the same data format, so registering a completely different topic would make little sense. 
  + PX4 can register multiple similar drivers with this API:
    ```
    struct mag_report new_report; 
    // advertise on the first call 
    int _mag_topic_instance; 
    _mag_topic = orb_advertise_multi(ORB_ID(sensor_mag), &_mag_topic_instance, &new_report); 
    // then publish on subsequent calls 
    orb_publish(ORB_ID(sensor_mag), _mag_topic, &new_report);
    ```












